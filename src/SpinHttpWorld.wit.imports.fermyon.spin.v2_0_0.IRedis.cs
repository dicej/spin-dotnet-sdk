// Generated by `wit-bindgen` 0.30.0. DO NOT EDIT!
// <auto-generated />
#nullable enable

using System;
using System.Runtime.CompilerServices;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0;

public interface IRedis {

    /**
    * Errors related to interacting with Redis
    */

    public class Error {
        public readonly byte Tag;
        private readonly object? value;

        private Error(byte tag, object? value) {
            this.Tag = tag;
            this.value = value;
        }

        public static Error invalidAddress() {
            return new Error(INVALID_ADDRESS, null);
        }

        public static Error tooManyConnections() {
            return new Error(TOO_MANY_CONNECTIONS, null);
        }

        public static Error typeError() {
            return new Error(TYPE_ERROR, null);
        }

        public static Error other(string other) {
            return new Error(OTHER, other);
        }

        public string AsOther
        {
            get
            {
                if (Tag == OTHER)
                return (string)value!;
                else
                throw new ArgumentException("expected OTHER, got " + Tag);
            }
        }

        public const byte INVALID_ADDRESS = 0;
        public const byte TOO_MANY_CONNECTIONS = 1;
        public const byte TYPE_ERROR = 2;
        public const byte OTHER = 3;
    }

    /**
    * A parameter type for the general-purpose `execute` function.
    */

    public class RedisParameter {
        public readonly byte Tag;
        private readonly object? value;

        private RedisParameter(byte tag, object? value) {
            this.Tag = tag;
            this.value = value;
        }

        public static RedisParameter int64(long int64) {
            return new RedisParameter(INT64, int64);
        }

        public static RedisParameter binary(byte[] binary) {
            return new RedisParameter(BINARY, binary);
        }

        public long AsInt64
        {
            get
            {
                if (Tag == INT64)
                return (long)value!;
                else
                throw new ArgumentException("expected INT64, got " + Tag);
            }
        }

        public byte[] AsBinary
        {
            get
            {
                if (Tag == BINARY)
                return (byte[])value!;
                else
                throw new ArgumentException("expected BINARY, got " + Tag);
            }
        }

        public const byte INT64 = 0;
        public const byte BINARY = 1;
    }

    /**
    * A return type for the general-purpose `execute` function.
    */

    public class RedisResult {
        public readonly byte Tag;
        private readonly object? value;

        private RedisResult(byte tag, object? value) {
            this.Tag = tag;
            this.value = value;
        }

        public static RedisResult nil() {
            return new RedisResult(NIL, null);
        }

        public static RedisResult status(string status) {
            return new RedisResult(STATUS, status);
        }

        public static RedisResult int64(long int64) {
            return new RedisResult(INT64, int64);
        }

        public static RedisResult binary(byte[] binary) {
            return new RedisResult(BINARY, binary);
        }

        public string AsStatus
        {
            get
            {
                if (Tag == STATUS)
                return (string)value!;
                else
                throw new ArgumentException("expected STATUS, got " + Tag);
            }
        }

        public long AsInt64
        {
            get
            {
                if (Tag == INT64)
                return (long)value!;
                else
                throw new ArgumentException("expected INT64, got " + Tag);
            }
        }

        public byte[] AsBinary
        {
            get
            {
                if (Tag == BINARY)
                return (byte[])value!;
                else
                throw new ArgumentException("expected BINARY, got " + Tag);
            }
        }

        public const byte NIL = 0;
        public const byte STATUS = 1;
        public const byte INT64 = 2;
        public const byte BINARY = 3;
    }

    public class Connection: IDisposable {
        internal int Handle { get; set; }

        public readonly record struct THandle(int Handle);

        public Connection(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[resource-drop]connection"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        ~Connection() {
            Dispose(false);
        }

        internal static class OpenWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[static]connection.open"), WasmImportLinkage]
            internal static extern void wasmImportOpen(nint p0, int p1, nint p2);

        }

        public  static unsafe global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Connection Open(string address)
        {

            var result = address;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                OpenWasmInterop.wasmImportOpen(interopString.ToInt32(), lengthresult, ptr);

                Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Connection, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {
                        var resource = new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Connection(new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Connection.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4))));

                        lifted10 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Connection, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(resource);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted10 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Connection, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class PublishWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.publish"), WasmImportLinkage]
            internal static extern void wasmImportPublish(int p0, nint p1, int p2, nint p3, int p4, nint p5);

        }

        public   unsafe void Publish(string channel, byte[] payload)
        {
            var handle = this.Handle;

            var result = channel;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            void* buffer = stackalloc byte[(payload).Length];
            payload.AsSpan<byte>().CopyTo(new Span<byte>(buffer, payload.Length));

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                PublishWasmInterop.wasmImportPublish(handle, interopString.ToInt32(), lengthresult, (int)buffer, (payload).Length, ptr);

                Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(new global::SpinHttpWorld.None());
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class GetWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.get"), WasmImportLinkage]
            internal static extern void wasmImportGet(int p0, nint p1, int p2, nint p3);

        }

        public   unsafe byte[]? Get(string key)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                GetWasmInterop.wasmImportGet(handle, interopString.ToInt32(), lengthresult, ptr);

                Result<byte[]?, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted15;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        byte[]? lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {
                                lifted = null;
                                break;
                            }

                            case 1: {

                                var array = new byte[BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))];
                                new Span<byte>((void*)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4))), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))).CopyTo(new Span<byte>(array));

                                lifted = array;
                                break;
                            }

                            default: throw new ArgumentException("invalid discriminant: " + (new Span<byte>((void*)(ptr + 4), 1)[0]));
                        }

                        lifted15 = Result<byte[]?, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(lifted);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted14;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted15 = Result<byte[]?, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted14);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted15.IsOk) {
                    var tmp = lifted15.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted15.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SetWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.set"), WasmImportLinkage]
            internal static extern void wasmImportSet(int p0, nint p1, int p2, nint p3, int p4, nint p5);

        }

        public   unsafe void Set(string key, byte[] value)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            void* buffer = stackalloc byte[(value).Length];
            value.AsSpan<byte>().CopyTo(new Span<byte>(buffer, value.Length));

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SetWasmInterop.wasmImportSet(handle, interopString.ToInt32(), lengthresult, (int)buffer, (value).Length, ptr);

                Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(new global::SpinHttpWorld.None());
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class IncrWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.incr"), WasmImportLinkage]
            internal static extern void wasmImportIncr(int p0, nint p1, int p2, nint p3);

        }

        public   unsafe long Incr(string key)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new ulong[3];
            fixed (ulong* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                IncrWasmInterop.wasmImportIncr(handle, interopString.ToInt32(), lengthresult, ptr);

                Result<long, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted10 = Result<long, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(BitConverter.ToInt64(new Span<byte>((void*)(ptr + 8), 8)));
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 8), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 16), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 8), 1)[0]}");
                        }

                        lifted10 = Result<long, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class DelWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.del"), WasmImportLinkage]
            internal static extern void wasmImportDel(int p0, nint p1, int p2, nint p3);

        }

        public   unsafe uint Del(List<string> keys)
        {
            var handle = this.Handle;

            byte[] buffer = new byte[8 * keys.Count];
            var gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var address = gcHandle.AddrOfPinnedObject();

            for (int index = 0; index < keys.Count; ++index) {
                string element = keys[index];
                int basePtr = (int)address + (index * 8);

                var result = element;
                IntPtr interopString = InteropString.FromString(result, out int lengthresult);
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 4), 4), unchecked((int)lengthresult));
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 0), 4), unchecked((int)interopString.ToInt32()));

            }

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                DelWasmInterop.wasmImportDel(handle, (int)address, keys.Count, ptr);

                Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted12;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted12 = Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)))));
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted12 = Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                gcHandle.Free();
                if (lifted12.IsOk) {
                    var tmp = lifted12.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted12.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SaddWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.sadd"), WasmImportLinkage]
            internal static extern void wasmImportSadd(int p0, nint p1, int p2, nint p3, int p4, nint p5);

        }

        public   unsafe uint Sadd(string key, List<string> values)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            byte[] buffer = new byte[8 * values.Count];
            var gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var address = gcHandle.AddrOfPinnedObject();

            for (int index = 0; index < values.Count; ++index) {
                string element = values[index];
                int basePtr = (int)address + (index * 8);

                var result1 = element;
                IntPtr interopString0 = InteropString.FromString(result1, out int lengthresult1);
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 4), 4), unchecked((int)lengthresult1));
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 0), 4), unchecked((int)interopString0.ToInt32()));

            }

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SaddWasmInterop.wasmImportSadd(handle, interopString.ToInt32(), lengthresult, (int)address, values.Count, ptr);

                Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted14;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted14 = Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)))));
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted14 = Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                gcHandle.Free();
                if (lifted14.IsOk) {
                    var tmp = lifted14.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted14.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SmembersWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.smembers"), WasmImportLinkage]
            internal static extern void wasmImportSmembers(int p0, nint p1, int p2, nint p3);

        }

        public   unsafe List<string> Smembers(string key)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SmembersWasmInterop.wasmImportSmembers(handle, interopString.ToInt32(), lengthresult, ptr);

                Result<List<string>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted12;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        var array = new List<string>(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)));
                        for (int index = 0; index < BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)); ++index) {
                            nint basePtr1 = BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)) + (index * 8);

                            array.Add(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 0), 4)), BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 4), 4))));
                        }

                        lifted12 = Result<List<string>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(array);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted12 = Result<List<string>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted12.IsOk) {
                    var tmp = lifted12.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted12.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SremWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.srem"), WasmImportLinkage]
            internal static extern void wasmImportSrem(int p0, nint p1, int p2, nint p3, int p4, nint p5);

        }

        public   unsafe uint Srem(string key, List<string> values)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            byte[] buffer = new byte[8 * values.Count];
            var gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            var address = gcHandle.AddrOfPinnedObject();

            for (int index = 0; index < values.Count; ++index) {
                string element = values[index];
                int basePtr = (int)address + (index * 8);

                var result1 = element;
                IntPtr interopString0 = InteropString.FromString(result1, out int lengthresult1);
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 4), 4), unchecked((int)lengthresult1));
                BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 0), 4), unchecked((int)interopString0.ToInt32()));

            }

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SremWasmInterop.wasmImportSrem(handle, interopString.ToInt32(), lengthresult, (int)address, values.Count, ptr);

                Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted14;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted14 = Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(unchecked((uint)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)))));
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted14 = Result<uint, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                gcHandle.Free();
                if (lifted14.IsOk) {
                    var tmp = lifted14.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted14.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class ExecuteWasmInterop
        {
            [DllImport("fermyon:spin/redis@2.0.0", EntryPoint = "[method]connection.execute"), WasmImportLinkage]
            internal static extern void wasmImportExecute(int p0, nint p1, int p2, nint p3, int p4, nint p5);

        }

        public   unsafe List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult> Execute(string command, List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisParameter> arguments)
        {
            var handle = this.Handle;

            var result = command;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            byte[] buffer5 = new byte[16 * arguments.Count];
            var gcHandle = GCHandle.Alloc(buffer5, GCHandleType.Pinned);
            var address = gcHandle.AddrOfPinnedObject();

            for (int index = 0; index < arguments.Count; ++index) {
                global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisParameter element = arguments[index];
                int basePtr = (int)address + (index * 16);

                switch (element.Tag) {
                    case 0: {
                        long payload = element.AsInt64;
                        *(byte*)(basePtr + 0) = (byte)0;
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 8), 8), unchecked((long)payload));

                        break;
                    }
                    case 1: {
                        byte[] payload4 = element.AsBinary;
                        *(byte*)(basePtr + 0) = (byte)1;

                        void* buffer = stackalloc byte[(payload4).Length];
                        payload4.AsSpan<byte>().CopyTo(new Span<byte>(buffer, payload4.Length));
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 12), 4), unchecked((int)(payload4).Length));
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 8), 4), unchecked((int)(int)buffer));

                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {element}");
                }

            }

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                ExecuteWasmInterop.wasmImportExecute(handle, interopString.ToInt32(), lengthresult, (int)address, arguments.Count, ptr);

                Result<List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error> lifted31;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        var array18 = new List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult>(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)));
                        for (int index19 = 0; index19 < BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)); ++index19) {
                            nint basePtr9 = BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)) + (index19 * 16);

                            global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult lifted;

                            switch (new Span<byte>((void*)(basePtr9 + 0), 1)[0]) {
                                case 0: {

                                    lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult.nil();
                                    break;
                                }
                                case 1: {

                                    lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult.status(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(basePtr9 + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(basePtr9 + 12), 4))));
                                    break;
                                }
                                case 2: {

                                    lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult.int64(BitConverter.ToInt64(new Span<byte>((void*)(basePtr9 + 8), 8)));
                                    break;
                                }
                                case 3: {

                                    var array = new byte[BitConverter.ToInt32(new Span<byte>((void*)(basePtr9 + 12), 4))];
                                    new Span<byte>((void*)(BitConverter.ToInt32(new Span<byte>((void*)(basePtr9 + 8), 4))), BitConverter.ToInt32(new Span<byte>((void*)(basePtr9 + 12), 4))).CopyTo(new Span<byte>(array));

                                    lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult.binary(array);
                                    break;
                                }

                                default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(basePtr9 + 0), 1)[0]}");
                            }

                            array18.Add(lifted);
                        }

                        lifted31 = Result<List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.ok(array18);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error lifted30;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted30 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.invalidAddress();
                                break;
                            }
                            case 1: {

                                lifted30 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.tooManyConnections();
                                break;
                            }
                            case 2: {

                                lifted30 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.typeError();
                                break;
                            }
                            case 3: {

                                lifted30 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted31 = Result<List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.RedisResult>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IRedis.Error>.err(lifted30);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                gcHandle.Free();
                if (lifted31.IsOk) {
                    var tmp = lifted31.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted31.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

    }

}
