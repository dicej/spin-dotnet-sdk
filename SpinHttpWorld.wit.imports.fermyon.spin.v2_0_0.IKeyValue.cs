// Generated by `wit-bindgen` 0.28.0. DO NOT EDIT!
// <auto-generated />
#nullable enable

using System;
using System.Runtime.CompilerServices;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0;

public interface IKeyValue {

    /**
    * The set of errors which may be raised by functions in this interface
    */

    public class Error {
        public readonly byte Tag;
        private readonly object? value;

        private Error(byte tag, object? value) {
            this.Tag = tag;
            this.value = value;
        }

        public static Error storeTableFull() {
            return new Error(STORE_TABLE_FULL, null);
        }

        public static Error noSuchStore() {
            return new Error(NO_SUCH_STORE, null);
        }

        public static Error accessDenied() {
            return new Error(ACCESS_DENIED, null);
        }

        public static Error other(string other) {
            return new Error(OTHER, other);
        }

        public string AsOther
        {
            get
            {
                if (Tag == OTHER)
                return (string)value!;
                else
                throw new ArgumentException("expected OTHER, got " + Tag);
            }
        }

        public const byte STORE_TABLE_FULL = 0;
        public const byte NO_SUCH_STORE = 1;
        public const byte ACCESS_DENIED = 2;
        public const byte OTHER = 3;
    }

    /**
    * An open key-value store
    */

    public class Store: IDisposable {
        internal int Handle { get; set; }

        internal readonly record struct THandle(int Handle);

        internal Store(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        [DllImport("fermyon:spin/key-value@2.0.0", EntryPoint = "[resource-drop]store"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        ~Store() {
            Dispose(false);
        }

        internal static class OpenWasmInterop
        {
            [DllImport("fermyon:spin/key-value@2.0.0", EntryPoint = "[static]store.open"), WasmImportLinkage]
            internal static extern void wasmImportOpen(nint p0, int p1, nint p2);

        }

        internal  static unsafe global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Store Open(string label)
        {

            var result = label;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                OpenWasmInterop.wasmImportOpen(interopString.ToInt32(), lengthresult, ptr);

                Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Store, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {
                        var resource = new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Store(new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Store.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4))));

                        lifted10 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Store, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.ok(resource);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.storeTableFull();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.noSuchStore();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.accessDenied();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted10 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Store, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class GetWasmInterop
        {
            [DllImport("fermyon:spin/key-value@2.0.0", EntryPoint = "[method]store.get"), WasmImportLinkage]
            internal static extern void wasmImportGet(int p0, nint p1, int p2, nint p3);

        }

        internal   unsafe byte[]? Get(string key)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                GetWasmInterop.wasmImportGet(handle, interopString.ToInt32(), lengthresult, ptr);

                Result<byte[]?, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error> lifted15;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        byte[]? lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {
                                lifted = null;
                                break;
                            }

                            case 1: {

                                var array = new byte[BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))];
                                new Span<byte>((void*)(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4))), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))).CopyTo(new Span<byte>(array));

                                lifted = array;
                                break;
                            }

                            default: throw new ArgumentException("invalid discriminant: " + (new Span<byte>((void*)(ptr + 4), 1)[0]));
                        }

                        lifted15 = Result<byte[]?, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.ok(lifted);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error lifted14;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.storeTableFull();
                                break;
                            }
                            case 1: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.noSuchStore();
                                break;
                            }
                            case 2: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.accessDenied();
                                break;
                            }
                            case 3: {

                                lifted14 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted15 = Result<byte[]?, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.err(lifted14);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted15.IsOk) {
                    var tmp = lifted15.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted15.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class SetWasmInterop
        {
            [DllImport("fermyon:spin/key-value@2.0.0", EntryPoint = "[method]store.set"), WasmImportLinkage]
            internal static extern void wasmImportSet(int p0, nint p1, int p2, nint p3, int p4, nint p5);

        }

        internal   unsafe void Set(string key, byte[] value)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            void* buffer = stackalloc byte[(value).Length];
            value.AsSpan<byte>().CopyTo(new Span<byte>(buffer, value.Length));

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                SetWasmInterop.wasmImportSet(handle, interopString.ToInt32(), lengthresult, (int)buffer, (value).Length, ptr);

                Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.ok(new global::SpinHttpWorld.None());
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.storeTableFull();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.noSuchStore();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.accessDenied();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class DeleteWasmInterop
        {
            [DllImport("fermyon:spin/key-value@2.0.0", EntryPoint = "[method]store.delete"), WasmImportLinkage]
            internal static extern void wasmImportDelete(int p0, nint p1, int p2, nint p3);

        }

        internal   unsafe void Delete(string key)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                DeleteWasmInterop.wasmImportDelete(handle, interopString.ToInt32(), lengthresult, ptr);

                Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.ok(new global::SpinHttpWorld.None());
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.storeTableFull();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.noSuchStore();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.accessDenied();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted10 = Result<None, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return ;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class ExistsWasmInterop
        {
            [DllImport("fermyon:spin/key-value@2.0.0", EntryPoint = "[method]store.exists"), WasmImportLinkage]
            internal static extern void wasmImportExists(int p0, nint p1, int p2, nint p3);

        }

        internal   unsafe bool Exists(string key)
        {
            var handle = this.Handle;

            var result = key;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                ExistsWasmInterop.wasmImportExists(handle, interopString.ToInt32(), lengthresult, ptr);

                Result<bool, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error> lifted10;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        lifted10 = Result<bool, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.ok((new Span<byte>((void*)(ptr + 4), 1)[0] != 0));
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.storeTableFull();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.noSuchStore();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.accessDenied();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted10 = Result<bool, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted10.IsOk) {
                    var tmp = lifted10.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted10.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class GetKeysWasmInterop
        {
            [DllImport("fermyon:spin/key-value@2.0.0", EntryPoint = "[method]store.get-keys"), WasmImportLinkage]
            internal static extern void wasmImportGetKeys(int p0, nint p1);

        }

        internal   unsafe List<string> GetKeys()
        {
            var handle = this.Handle;

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                GetKeysWasmInterop.wasmImportGetKeys(handle, ptr);

                Result<List<string>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error> lifted12;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        var array = new List<string>(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)));
                        for (int index = 0; index < BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)); ++index) {
                            nint basePtr1 = BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)) + (index * 8);

                            array.Add(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 0), 4)), BitConverter.ToInt32(new Span<byte>((void*)(basePtr1 + 4), 4))));
                        }

                        lifted12 = Result<List<string>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.ok(array);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.storeTableFull();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.noSuchStore();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.accessDenied();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error.other(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted12 = Result<List<string>, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.IKeyValue.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted12.IsOk) {
                    var tmp = lifted12.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted12.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

    }

}
