// Generated by `wit-bindgen` 0.28.0. DO NOT EDIT!
// <auto-generated />
#nullable enable

using System;
using System.Runtime.CompilerServices;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0;

public interface ISqlite {

    /**
    * The set of errors which may be raised by functions in this interface
    */

    public class Error {
        public readonly byte Tag;
        private readonly object? value;

        private Error(byte tag, object? value) {
            this.Tag = tag;
            this.value = value;
        }

        public static Error noSuchDatabase() {
            return new Error(NO_SUCH_DATABASE, null);
        }

        public static Error accessDenied() {
            return new Error(ACCESS_DENIED, null);
        }

        public static Error invalidConnection() {
            return new Error(INVALID_CONNECTION, null);
        }

        public static Error databaseFull() {
            return new Error(DATABASE_FULL, null);
        }

        public static Error io(string io) {
            return new Error(IO, io);
        }

        public string AsIo
        {
            get
            {
                if (Tag == IO)
                return (string)value!;
                else
                throw new ArgumentException("expected IO, got " + Tag);
            }
        }

        public const byte NO_SUCH_DATABASE = 0;
        public const byte ACCESS_DENIED = 1;
        public const byte INVALID_CONNECTION = 2;
        public const byte DATABASE_FULL = 3;
        public const byte IO = 4;
    }

    /**
    * A single column's result from a database query
    */

    public class Value {
        public readonly byte Tag;
        private readonly object? value;

        private Value(byte tag, object? value) {
            this.Tag = tag;
            this.value = value;
        }

        public static Value integer(long integer) {
            return new Value(INTEGER, integer);
        }

        public static Value real(double real) {
            return new Value(REAL, real);
        }

        public static Value text(string text) {
            return new Value(TEXT, text);
        }

        public static Value blob(byte[] blob) {
            return new Value(BLOB, blob);
        }

        public static Value @null() {
            return new Value(NULL, null);
        }

        public long AsInteger
        {
            get
            {
                if (Tag == INTEGER)
                return (long)value!;
                else
                throw new ArgumentException("expected INTEGER, got " + Tag);
            }
        }

        public double AsReal
        {
            get
            {
                if (Tag == REAL)
                return (double)value!;
                else
                throw new ArgumentException("expected REAL, got " + Tag);
            }
        }

        public string AsText
        {
            get
            {
                if (Tag == TEXT)
                return (string)value!;
                else
                throw new ArgumentException("expected TEXT, got " + Tag);
            }
        }

        public byte[] AsBlob
        {
            get
            {
                if (Tag == BLOB)
                return (byte[])value!;
                else
                throw new ArgumentException("expected BLOB, got " + Tag);
            }
        }

        public const byte INTEGER = 0;
        public const byte REAL = 1;
        public const byte TEXT = 2;
        public const byte BLOB = 3;
        public const byte NULL = 4;
    }

    /**
    * A set of values for each of the columns in a query-result
    */

    public class RowResult {
        public readonly List<Value> values;

        public RowResult(List<Value> values) {
            this.values = values;
        }
    }

    /**
    * A result of a query
    */

    public class QueryResult {
        public readonly List<string> columns;
        public readonly List<RowResult> rows;

        public QueryResult(List<string> columns, List<RowResult> rows) {
            this.columns = columns;
            this.rows = rows;
        }
    }

    /**
    * A handle to an open sqlite instance
    */

    public class Connection: IDisposable {
        internal int Handle { get; set; }

        internal readonly record struct THandle(int Handle);

        internal Connection(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        [DllImport("fermyon:spin/sqlite@2.0.0", EntryPoint = "[resource-drop]connection"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        ~Connection() {
            Dispose(false);
        }

        internal static class OpenWasmInterop
        {
            [DllImport("fermyon:spin/sqlite@2.0.0", EntryPoint = "[static]connection.open"), WasmImportLinkage]
            internal static extern void wasmImportOpen(nint p0, int p1, nint p2);

        }

        internal  static unsafe global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Connection Open(string database)
        {

            var result = database;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[4];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                OpenWasmInterop.wasmImportOpen(interopString.ToInt32(), lengthresult, ptr);

                Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Connection, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error> lifted12;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {
                        var resource = new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Connection(new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Connection.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4))));

                        lifted12 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Connection, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error>.ok(resource);
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error lifted;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.noSuchDatabase();
                                break;
                            }
                            case 1: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.accessDenied();
                                break;
                            }
                            case 2: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.invalidConnection();
                                break;
                            }
                            case 3: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.databaseFull();
                                break;
                            }
                            case 4: {

                                lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.io(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted12 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Connection, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error>.err(lifted);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted12.IsOk) {
                    var tmp = lifted12.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted12.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class ExecuteWasmInterop
        {
            [DllImport("fermyon:spin/sqlite@2.0.0", EntryPoint = "[method]connection.execute"), WasmImportLinkage]
            internal static extern void wasmImportExecute(int p0, nint p1, int p2, nint p3, int p4, nint p5);

        }

        internal   unsafe global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.QueryResult Execute(string statement, List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value> parameters)
        {
            var handle = this.Handle;

            var result = statement;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            byte[] buffer16 = new byte[16 * parameters.Count];
            var gcHandle = GCHandle.Alloc(buffer16, GCHandleType.Pinned);
            var address = gcHandle.AddrOfPinnedObject();

            for (int index = 0; index < parameters.Count; ++index) {
                global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value element = parameters[index];
                int basePtr = (int)address + (index * 16);

                switch (element.Tag) {
                    case 0: {
                        long payload = element.AsInteger;
                        *(byte*)(basePtr + 0) = (byte)0;
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 8), 8), unchecked((long)payload));

                        break;
                    }
                    case 1: {
                        double payload4 = element.AsReal;
                        *(byte*)(basePtr + 0) = (byte)1;
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 8), 8), unchecked((double)payload4));

                        break;
                    }
                    case 2: {
                        string payload7 = element.AsText;
                        *(byte*)(basePtr + 0) = (byte)2;

                        var result9 = payload7;
                        IntPtr interopString8 = InteropString.FromString(result9, out int lengthresult9);
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 12), 4), unchecked((int)lengthresult9));
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 8), 4), unchecked((int)interopString8.ToInt32()));

                        break;
                    }
                    case 3: {
                        byte[] payload12 = element.AsBlob;
                        *(byte*)(basePtr + 0) = (byte)3;

                        void* buffer = stackalloc byte[(payload12).Length];
                        payload12.AsSpan<byte>().CopyTo(new Span<byte>(buffer, payload12.Length));
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 12), 4), unchecked((int)(payload12).Length));
                        BitConverter.TryWriteBytes(new Span<byte>((void*)(basePtr + 8), 4), unchecked((int)(int)buffer));

                        break;
                    }
                    case 4: {

                        *(byte*)(basePtr + 0) = (byte)4;

                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {element}");
                }

            }

            var retArea = new uint[5];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                ExecuteWasmInterop.wasmImportExecute(handle, interopString.ToInt32(), lengthresult, (int)address, parameters.Count, ptr);

                Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.QueryResult, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error> lifted54;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {

                        var array = new List<string>(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)));
                        for (int index21 = 0; index21 < BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)); ++index21) {
                            nint basePtr20 = BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4)) + (index21 * 8);

                            array.Add(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(basePtr20 + 0), 4)), BitConverter.ToInt32(new Span<byte>((void*)(basePtr20 + 4), 4))));
                        }

                        var array39 = new List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.RowResult>(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 16), 4)));
                        for (int index40 = 0; index40 < BitConverter.ToInt32(new Span<byte>((void*)(ptr + 16), 4)); ++index40) {
                            nint basePtr23 = BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4)) + (index40 * 8);

                            var array37 = new List<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value>(BitConverter.ToInt32(new Span<byte>((void*)(basePtr23 + 4), 4)));
                            for (int index38 = 0; index38 < BitConverter.ToInt32(new Span<byte>((void*)(basePtr23 + 4), 4)); ++index38) {
                                nint basePtr25 = BitConverter.ToInt32(new Span<byte>((void*)(basePtr23 + 0), 4)) + (index38 * 16);

                                global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value lifted;

                                switch (new Span<byte>((void*)(basePtr25 + 0), 1)[0]) {
                                    case 0: {

                                        lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value.integer(BitConverter.ToInt64(new Span<byte>((void*)(basePtr25 + 8), 8)));
                                        break;
                                    }
                                    case 1: {

                                        lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value.real(BitConverter.ToDouble(new Span<byte>((void*)(basePtr25 + 8), 8)));
                                        break;
                                    }
                                    case 2: {

                                        lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value.text(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(basePtr25 + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(basePtr25 + 12), 4))));
                                        break;
                                    }
                                    case 3: {

                                        var array34 = new byte[BitConverter.ToInt32(new Span<byte>((void*)(basePtr25 + 12), 4))];
                                        new Span<byte>((void*)(BitConverter.ToInt32(new Span<byte>((void*)(basePtr25 + 8), 4))), BitConverter.ToInt32(new Span<byte>((void*)(basePtr25 + 12), 4))).CopyTo(new Span<byte>(array34));

                                        lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value.blob(array34);
                                        break;
                                    }
                                    case 4: {

                                        lifted = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Value.@null();
                                        break;
                                    }

                                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(basePtr25 + 0), 1)[0]}");
                                }

                                array37.Add(lifted);
                            }

                            array39.Add(new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.RowResult (
                            array37));
                        }

                        lifted54 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.QueryResult, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error>.ok(new global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.QueryResult (
                        array, array39));
                        break;
                    }
                    case 1: {

                        global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error lifted53;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                lifted53 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.noSuchDatabase();
                                break;
                            }
                            case 1: {

                                lifted53 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.accessDenied();
                                break;
                            }
                            case 2: {

                                lifted53 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.invalidConnection();
                                break;
                            }
                            case 3: {

                                lifted53 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.databaseFull();
                                break;
                            }
                            case 4: {

                                lifted53 = global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error.io(Encoding.UTF8.GetString((byte*)BitConverter.ToInt32(new Span<byte>((void*)(ptr + 8), 4)), BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted54 = Result<global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.QueryResult, global::SpinHttpWorld.wit.imports.fermyon.spin.v2_0_0.ISqlite.Error>.err(lifted53);
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                gcHandle.Free();
                if (lifted54.IsOk) {
                    var tmp = lifted54.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted54.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

    }

}
